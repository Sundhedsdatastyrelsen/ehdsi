package dk.sundhedsdatastyrelsen.ncpeh.cda; import dk.dkma.medicinecard.xml_schema._2015._06._01.DosageAnyDayType; import dk.dkma.medicinecard.xml_schema._2015._06._01.DosageDayType; import dk.dkma.medicinecard.xml_schema._2015._06._01.DosageStructureForResponseType; import dk.dkma.medicinecard.xml_schema._2015._06._01.DoseType; import dk.dkma.medicinecard.xml_schema._2015._06._01.EmptyDosageStructureType; import dk.dkma.medicinecard.xml_schema._2015._06._01.e2.DosageForResponseType; import dk.sundhedsdatastyrelsen.ncpeh.cda.model.Dosage; import lombok.NonNull; import lombok.extern.slf4j.Slf4j; import org.apache.commons.lang3.tuple.Pair; import java.math.BigDecimal; import java.math.RoundingMode; import java.time.LocalTime; import java.time.ZonedDateTime; import java.util.ArrayList; import java.util.List; import java.util.Objects; import java.util.Optional; import java.util.regex.Pattern; @Slf4j public final class DosageMapper { private DosageMapper() { } public static @NonNull Dosage model(@NonNull DosageForResponseType dosage) { final var unstructuredText = getUnstructuredText(dosage); final var unit = mapUnit(dosage); if (unit == null) { return new Dosage.Unstructured(unstructuredText, "Could not parse dosage unit."); } if (dosage.getAdministrationAccordingToSchemaInLocalSystem() != null || dosage.getFreeText() != null) { return new Dosage.Unstructured(unstructuredText, "DK model not structured."); } if (dosage.getStructuresFixed() == null && dosage.getStructuresAccordingToNeed() == null || dosage.getStructuresFixed() != null && dosage.getStructuresAccordingToNeed() != null) { return new Dosage.Unstructured(unstructuredText, "Both fixed and according to need or both missing."); } var structures = dosage.getStructuresFixed() != null ? dosage.getStructuresFixed() : dosage.getStructuresAccordingToNeed(); if (structures.getEmptyStructureOrStructure().size() != 1) { return new Dosage.Unstructured(unstructuredText, "Multiple dosage structures."); } var structure = getStructureOrNull(structures.getEmptyStructureOrStructure().getFirst()); if (structure == null) { return new Dosage.Unstructured(unstructuredText, "No dosage structure."); } return mapStructure(structure, unit, unstructuredText, dosage.getStructuresAccordingToNeed() != null); } static @NonNull String getUnstructuredText(@NonNull DosageForResponseType dosage) { final var unstructuredTexts = new ArrayList<String>(); if (dosage.getStructuresFixed() != null && dosage.getStructuresFixed() .getDosageTranslationCombined() != null && dosage.getStructuresFixed() .getDosageTranslationCombined() .getLongText() != null) { unstructuredTexts.add(dosage.getStructuresFixed().getDosageTranslationCombined().getLongText()); } if (dosage.getStructuresAccordingToNeed() != null && dosage.getStructuresAccordingToNeed() .getDosageTranslationCombined() != null && dosage.getStructuresAccordingToNeed() .getDosageTranslationCombined() .getLongText() != null) { unstructuredTexts.add(dosage.getStructuresAccordingToNeed().getDosageTranslationCombined().getLongText()); } if (dosage.getFreeText() != null && dosage.getFreeText().getText() != null) { unstructuredTexts.add(dosage.getFreeText().getText()); } final var builder = new StringBuilder(); for (String s : unstructuredTexts) { if (!builder.isEmpty()) { builder.append("\n\n"); } builder.append(s); } return builder.isEmpty() ? "No unstructured dosage text" : builder.toString(); } static DosageStructureForResponseType getStructureOrNull(@NonNull Object emptyStructureOrStructure) { switch (emptyStructureOrStructure) { case DosageStructureForResponseType ds: return ds; case EmptyDosageStructureType ignored: return null; default: log.warn("Unknown dosage structure type {}", emptyStructureOrStructure.getClass().getName()); return null; } } static @NonNull Dosage mapStructure(@NonNull DosageStructureForResponseType structure, @NonNull Dosage.Unit unit, @NonNull String unstructuredText, boolean isAccordingToNeed) { if (structure.getNotIterated() == null && structure.getIterationInterval() == null) { return new Dosage.Unstructured(unstructuredText, "Structure neither iterated nor not iterated."); } var structureWithoutAnyDay = structure.getAnyDay() == null ? structure : structure.newCopyBuilder() .withAnyDay(null) .withDay(anyDayToNormalDay(structure.getAnyDay())) .build(); if (isUnboundedAccordingToNeedCase(structureWithoutAnyDay, isAccordingToNeed)) { return mapUnboundedAccordingToNeed(structureWithoutAnyDay, unit, unstructuredText); } if (structureWithoutAnyDay.getNotIterated() != null) { return mapNotIterated(structureWithoutAnyDay, unit, unstructuredText, isAccordingToNeed); } if (structureWithoutAnyDay.getIterationInterval() == 1) { return mapIteratedDaily(structureWithoutAnyDay, unit, unstructuredText, isAccordingToNeed); } return mapIteratedNonDaily(structureWithoutAnyDay, unit, unstructuredText, isAccordingToNeed); } static @NonNull Dosage mapUnboundedAccordingToNeed(@NonNull DosageStructureForResponseType structure, @NonNull Dosage.Unit unit, @NonNull String unstructuredText) { var day = structure.getAnyDay() != null ? anyDayToNormalDay(structure.getAnyDay()) : structure.getDay().getFirst(); return new Dosage.Unbounded(unstructuredText, mapDoseToQuantity(day.getDose().getFirst(), unit, true)); } static @NonNull Dosage mapNotIterated(@NonNull DosageStructureForResponseType structure, @NonNull Dosage.Unit unit, @NonNull String unstructuredText, boolean isAccordingToNeed) { if (structure.getDay() == null) { return new Dosage.Unstructured(unstructuredText, "No days in not iterated structure."); } if (structure.getDay().size() == 1 && structure.getDay().getFirst().getDose().size() == 1) { var day = structure.getDay().getFirst(); var time = day.getDose().getFirst().getTime(); var startDateTime = structure.getStartDate().toGregorianCalendar().toZonedDateTime(); var transformedTime = time == null ? null : fmkTimeToLocalTime(time); if (time != null && transformedTime == null) { return new Dosage.Unstructured(unstructuredText, "Not iterated time could not be mapped."); } return new Dosage.Once( unstructuredText, transformedTime == null ? Either.ofLeft(Utils.convertToLocalDate(structure.getStartDate())) : Either.ofRight(ZonedDateTime.of(startDateTime.toLocalDate(), transformedTime.getLeft(), startDateTime.getZone())), mapDoseToQuantity(day.getDose().getFirst(), unit, isAccordingToNeed)); } return new Dosage.Unstructured(unstructuredText, "Multiple non-repeated doses."); } static @NonNull Dosage mapIteratedDaily(@NonNull DosageStructureForResponseType structure, @NonNull Dosage.Unit unit, @NonNull String unstructuredText, boolean isAccordingToNeed) { var days = structure.getDay(); if (days == null || days.size() != 1) { return new Dosage.Unstructured(unstructuredText, "Daily structure with days.size() != 1."); } var day = days.getFirst(); var doses = day.getDose(); var firstDose = doses.getFirst(); if (doses.size() == 1) { return new Dosage.PeriodicInterval( unstructuredText, true, new Dosage.Period.Simple("d", BigDecimal.valueOf(1)), mapDoseToQuantity(firstDose, unit, isAccordingToNeed)); } if (!dosesHaveSameQuantity(doses)) { return new Dosage.Unstructured(unstructuredText, "Daily doses with different quantities."); } if (doses.stream().anyMatch(d -> d.getTime() != null)) { return new Dosage.Unstructured(unstructuredText, "Daily dose with time."); } if (24 % doses.size() > 0) { return new Dosage.Unstructured(unstructuredText, "Daily dose doesn't fit 24h."); } return new Dosage.PeriodicInterval( unstructuredText, true, new Dosage.Period.Simple( "h", BigDecimal.valueOf(24).divide(BigDecimal.valueOf(doses.size()), RoundingMode.UNNECESSARY)), mapDoseToQuantity(firstDose, unit, isAccordingToNeed)); } static @NonNull Dosage mapIteratedNonDaily(@NonNull DosageStructureForResponseType structure, @NonNull Dosage.Unit unit, @NonNull String unstructuredText, boolean isAccordingToNeed) { var dayDistance = getDayDistance(structure.getIterationInterval(), structure.getDay()); var allSingleDose = structure.getDay().stream().allMatch(d -> d.getDose().size() == 1); var allDoses = structure.getDay().stream().flatMap(d -> d.getDose().stream()).toList(); if (dayDistance.isEmpty() || !allSingleDose || !dosesHaveSameQuantity(allDoses) || !dosesHaveSameTime(allDoses)) { return new Dosage.Unstructured(unstructuredText, "Iterated non daily with unequal distance, multiple doses per day, different quantities, or different times."); } if (allDoses.stream().anyMatch(d -> d.getTime() != null)) { return new Dosage.Unstructured(unstructuredText, "Iterated non daily with time."); } return new Dosage.PeriodicInterval( unstructuredText, false, new Dosage.Period.Simple("d", BigDecimal.valueOf(dayDistance.get())), mapDoseToQuantity(allDoses.getFirst(), unit, isAccordingToNeed) ); } static Pair<LocalTime, Boolean> fmkTimeToLocalTime(@NonNull String fmkTime) { switch (fmkTime) { case "morning": return Pair.of(LocalTime.of(8, 0), false); case "noon": return Pair.of(LocalTime.of(12, 0), false); case "evening": return Pair.of(LocalTime.of(18, 0), false); case "night": return Pair.of(LocalTime.of(22, 0), false); default: break; } var pattern = Pattern.compile("^(\\d?\\d).(\\d\\d)$"); var matcher = pattern.matcher(fmkTime); if (!matcher.matches()) { return null; } var hours = Integer.parseInt(matcher.group(1)); var minutes = Integer.parseInt(matcher.group(2)); if (hours < 0 || hours > 23 || minutes < 0 || minutes > 59) { return null; } return Pair.of(LocalTime.of(hours, minutes), true); } static Dosage.Unit mapUnit(@NonNull DosageForResponseType dosage) { var singular = dosage.getUnitText(); var plural = dosage.getUnitTexts(); var text = singular != null ? singular : plural == null ? null : plural.getSingular() != null ? plural.getSingular() : plural.getPlural(); return text == null ? null : new Dosage.Unit.Translated(text); } static Dosage.Quantity mapDoseToQuantity(@NonNull DoseType dose, @NonNull Dosage.Unit unit, boolean isAccordingToNeed) { if (dose.getQuantity() != null) { return new Dosage.Quantity(dose.getQuantity(), unit, isAccordingToNeed ? BigDecimal.ZERO : null); } var min = Optional.ofNullable(dose.getMinimalQuantity()).orElse(BigDecimal.ZERO); var max = dose.getMaximalQuantity(); if (max == null) { return null; } if (isAccordingToNeed && !min.equals(BigDecimal.ZERO) && !min.equals(BigDecimal.ONE) && !min.equals(max)) { return null; } return new Dosage.Quantity(max, unit, isAccordingToNeed ? BigDecimal.ZERO : min); } public static Optional<Integer> getDayDistance(int iterationInterval, @NonNull List<DosageDayType> days) { var firstDay = days.getFirst(); if (firstDay.getNumber() != 1) { return Optional.empty(); } if (days.size() == 1) { return Optional.of(iterationInterval); } var firstInterval = days.get(1).getNumber() - firstDay.getNumber(); for (int i = 1; i < days.size(); i++) { if (days.get(i).getNumber() - days.get(i - 1).getNumber() != firstInterval) { return Optional.empty(); } } return iterationInterval - days.getLast() .getNumber() + 1 == firstInterval ? Optional.of(firstInterval) : Optional.empty(); } static boolean dosesHaveSameQuantity(@NonNull List<DoseType> doses) { var firstDose = doses.getFirst(); return doses.stream().allMatch(d -> Objects.equals(firstDose.getQuantity(), d.getQuantity()) && Objects.equals(firstDose.getMaximalQuantity(), d.getMaximalQuantity()) && Objects.equals(firstDose.getMinimalQuantity(), d.getMinimalQuantity())); } static boolean dosesHaveSameTime(@NonNull List<DoseType> doses) { var firstDoseTime = doses.getFirst().getTime(); return doses.stream().allMatch(d -> Objects.equals(d.getTime(), firstDoseTime)); } static boolean isUnboundedAccordingToNeedCase(@NonNull DosageStructureForResponseType structure, boolean isAccordingToNeed) { return isAccordingToNeed && structure.getNotIterated() != null && (structure.getAnyDay() != null && structure.getAnyDay().getDose().size() == 1 || structure.getDay().size() == 1 && structure.getDay().getFirst().getDose().size() == 1); } static @NonNull DosageDayType anyDayToNormalDay(@NonNull DosageAnyDayType anyDay) { var copiedDoses = anyDay.getDose() .stream() .map(d -> DoseType.builder() .withQuantity(d.getQuantity()) .withMaximalQuantity(d.getMaximalQuantity()) .withMinimalQuantity(d.getMinimalQuantity()) .withTime(d.getTime()) .build()) .toList(); return DosageDayType.builder().withNumber(1).withDose(copiedDoses).build(); } } 